# src/ava/gui/node_viewer/project_visualizer_window.py
"""
Provides a real-time, animated visualization of the project structure as it's
being planned and generated by the AI.
"""
import logging
import math
from typing import Dict, List, Optional, Any

from PySide6.QtWidgets import (
    QMainWindow, QGraphicsView, QGraphicsScene, QGraphicsPathItem, QStyleOptionGraphicsItem, QWidget
)
from PySide6.QtCore import QPropertyAnimation, QEasingCurve, QPointF, Qt
from PySide6.QtGui import QPainter, QPen, QPainterPath, QPolygonF, QBrush, QCloseEvent

from src.ava.core.event_bus import EventBus
from src.ava.core.project_manager import ProjectManager
from src.ava.gui.components import Colors
from .project_node import ProjectNode

logger = logging.getLogger(__name__)


class ConnectionItem(QGraphicsPathItem):
    """
    Represents a directed connection (an arrow) between two ProjectNode items in the scene.
    It automatically updates its path when the connected nodes are moved.
    """

    def __init__(self, start_node: ProjectNode, end_node: ProjectNode, parent: Optional[QGraphicsItem] = None):
        """
        Initializes the ConnectionItem.

        Args:
            start_node: The ProjectNode where the connection originates.
            end_node: The ProjectNode where the connection terminates.
            parent: The parent QGraphicsItem in the scene.
        """
        super().__init__(parent)
        self.start_node = start_node
        self.end_node = end_node
        self.arrow_head = QPolygonF()

        self.setPen(QPen(Colors.TEXT_SECONDARY, 2, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap,
                         Qt.PenJoinStyle.RoundJoin))
        self.setZValue(-1)  # Draw connections behind nodes

        self.start_node.add_outgoing_connection(self)
        self.end_node.add_incoming_connection(self)
        self.update_path()

    def update_path(self) -> None:
        """
        Recalculates and updates the path of the line connecting the two nodes.
        This is called automatically when a connected node moves.
        """
        path = QPainterPath()
        start_pos = self.start_node.pos() + self.start_node.boundingRect().center()
        end_pos = self.end_node.pos() + self.end_node.boundingRect().center()
        path.moveTo(start_pos)
        path.lineTo(end_pos)
        self.setPath(path)
        self._update_arrowhead()

    def _update_arrowhead(self) -> None:
        """
        Calculates the geometry of the arrowhead at the end of the connection line.
        """
        line = self.path().toFillPolygon().first()
        if len(line) < 2:
            return

        p1 = line[-2]
        p2 = line[-1]

        angle = math.atan2(p2.y() - p1.y(), p2.x() - p1.x())
        arrow_size = 15.0

        arrow_p1 = p2 - QPointF(math.cos(angle + math.pi / 6) * arrow_size,
                                math.sin(angle + math.pi / 6) * arrow_size)
        arrow_p2 = p2 - QPointF(math.cos(angle - math.pi / 6) * arrow_size,
                                math.sin(angle - math.pi / 6) * arrow_size)

        self.arrow_head.clear()
        self.arrow_head << p2 << arrow_p1 << arrow_p2

    def paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: Optional[QWidget] = None) -> None:
        """
        Paints the connection line and its arrowhead.

        Args:
            painter: The QPainter to use for drawing.
            option: Provides style options for the item.
            widget: The widget that is being painted on, if any.
        """
        super().paint(painter, option, widget)
        painter.setBrush(QBrush(Colors.TEXT_SECONDARY))
        painter.setPen(Qt.PenStyle.NoPen)
        painter.drawPolygon(self.arrow_head)


class AICoreNode(ProjectNode):
    """A specialized ProjectNode representing the central AI core."""

    def __init__(self, name: str, parent: Optional[QGraphicsItem] = None):
        """
        Initializes the AICoreNode.

        Args:
            name: The display name of the node.
            parent: The parent QGraphicsItem in the scene.
        """
        super().__init__(name, node_type="root", parent=parent)


class ProjectVisualizerWindow(QMainWindow):
    """
    A window that provides a real-time, animated visualization of the project
    structure as it is being planned and generated by the AI.
    """

    def __init__(self, event_bus: EventBus, project_manager: ProjectManager):
        """
        Initializes the ProjectVisualizerWindow.

        Args:
            event_bus: The application's central event bus.
            project_manager: The manager for the active project.
        """
        super().__init__()
        self.event_bus = event_bus
        self.project_manager = project_manager

        self.setWindowTitle("Project Visualizer")
        self.setGeometry(150, 150, 1200, 800)

        self.scene = QGraphicsScene()
        self.scene.setBackgroundBrush(QBrush(Colors.PRIMARY_BG))

        self.view = QGraphicsView(self.scene)
        self.view.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.view.setDragMode(QGraphicsView.DragMode.ScrollHandDrag)

        self.setCentralWidget(self.view)

        self.nodes: Dict[str, ProjectNode] = {}
        self.final_positions: Dict[str, QPointF] = {}

        self._connect_events()

    def _connect_events(self) -> None:
        """Connects window methods to the application's event bus."""
        self.event_bus.subscribe("project_plan_generated", self._handle_project_plan_generated)
        self.event_bus.subscribe("file_generation_starting", self._handle_file_generation_starting)

    def _clear_view(self) -> None:
        """Clears the scene and resets the internal state of nodes and positions."""
        self.scene.clear()
        self.nodes.clear()
        self.final_positions.clear()

    def _handle_project_plan_generated(self, plan: Dict[str, Any]) -> None:
        """
        Handles the 'project_plan_generated' event from the ArchitectService.
        This sets up the initial state of the visualization.

        Args:
            plan: The project plan dictionary from the architect.
        """
        self._clear_view()
        logger.info(f"Visualizer received project plan with {len(plan.get('tasks', []))} tasks.")

        files = [item['filename'] for item in plan.get('tasks', []) if 'filename' in item]
        if not files:
            logger.warning("Visualizer received a plan with no files to visualize.")
            return

        self._calculate_grid_layout(files)

        root_node = AICoreNode("AI Core")
        root_node.setPos(self.view.width() / 2 - 75, 20)
        self.scene.addItem(root_node)
        self.nodes['root'] = root_node

    def _calculate_grid_layout(self, files: List[str]) -> None:
        """
        Calculates the final grid positions for all planned files and folders.

        Args:
            files: A list of relative file paths from the project plan.
        """
        x, y = 50, 150
        col_width = 200
        row_height = 100
        max_x = self.view.width() - col_width

        all_paths = set()
        for file_path in files:
            parts = file_path.split('/')
            for i in range(len(parts)):
                all_paths.add('/'.join(parts[:i + 1]))

        sorted_paths = sorted(list(all_paths))

        for path_str in sorted_paths:
            self.final_positions[path_str] = QPointF(x, y)
            x += col_width
            if x > max_x:
                x = 50
                y += row_height
        logger.info(f"Calculated final positions for {len(self.final_positions)} nodes.")

    def _handle_file_generation_starting(self, file_path: str) -> None:
        """
        Handles the 'file_generation_starting' event from the GenerationCoordinator.
        This creates and animates the new node into its final position.

        Args:
            file_path: The relative path of the file being generated.
        """
        logger.info(f"Visualizer animating node for: {file_path}")
        parts = file_path.split('/')
        parent_node = self.nodes.get('root')
        current_path = ""

        for i, part in enumerate(parts):
            is_last_part = (i == len(parts) - 1)

            if current_path:
                current_path += "/" + part
            else:
                current_path = part

            if current_path not in self.nodes:
                node_type = "file" if is_last_part else "folder"
                new_node = ProjectNode(part, node_type)

                start_pos = parent_node.pos() if parent_node else QPointF(0, 0)
                end_pos = self.final_positions.get(current_path, QPointF(100, 100))

                new_node.setPos(start_pos)
                self.scene.addItem(new_node)
                self.nodes[current_path] = new_node

                if parent_node:
                    connection = ConnectionItem(parent_node, new_node)
                    self.scene.addItem(connection)

                anim = QPropertyAnimation(new_node, b"pos")
                anim.setDuration(500)
                anim.setStartValue(start_pos)
                anim.setEndValue(end_pos)
                anim.setEasingCurve(QEasingCurve.OutCubic)
                anim.start()

            parent_node = self.nodes.get(current_path)

    def show(self) -> None:
        """Shows the window, raises it to the top, and activates it."""
        super().show()
        self.activateWindow()
        self.raise_()

    def closeEvent(self, event: QCloseEvent) -> None:
        """
        Overrides the default close event to simply hide the window,
        preserving its state.

        Args:
            event: The close event.
        """
        event.ignore()
        self.hide()