# src/ava/gui/node_viewer/project_visualizer_window.py
"""
Defines the main window, scene, and connection logic for the Project Visualizer.
This component provides a real-time, animated graph of the project structure
as it is being planned and generated by the AI.
"""
import logging
import math
from typing import Dict, List, Optional, Any

from PySide6.QtWidgets import (
    QMainWindow, QGraphicsView, QGraphicsScene, QGraphicsLineItem,
    QStyleOptionGraphicsItem, QWidget
)
from PySide6.QtCore import QPointF, QRectF, QTimer, Qt
from PySide6.QtGui import QPainter, QPen, QColor, QPolygonF

from src.ava.core.event_bus import EventBus
from src.ava.core.project_manager import ProjectManager
from src.ava.gui.components import Colors
from src.ava.gui.node_viewer.project_node import ProjectNode

logger = logging.getLogger(__name__)


class ConnectionItem(QGraphicsLineItem):
    """
    Represents a directed connection (an arrow) between two ProjectNode items.
    """
    def __init__(self, start_node: ProjectNode, end_node: ProjectNode):
        """
        Initializes the connection.

        Args:
            start_node: The node where the connection originates.
            end_node: The node where the connection terminates.
        """
        super().__init__()
        self.start_node = start_node
        self.end_node = end_node
        self.arrow_head = QPolygonF()

        self.setZValue(-1)  # Draw behind nodes
        self.pen = QPen(Colors.BORDER_DEFAULT, 2, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin)
        self.setPen(self.pen)

        self.start_node.add_outgoing_connection(self)
        self.end_node.add_incoming_connection(self)
        self.update_path()

    def update_path(self) -> None:
        """
        Recalculates the line and arrowhead path based on the current
        positions of the connected nodes.
        """
        if not self.start_node or not self.end_node:
            return

        start_pos = self.start_node.scenePos() + self.start_node.boundingRect().center()
        end_pos = self.end_node.scenePos() + self.end_node.boundingRect().center()
        line = QPointF(end_pos - start_pos)
        self.setLine(start_pos.x(), start_pos.y(), end_pos.x(), end_pos.y())

        # Arrowhead calculation
        angle = math.atan2(-line.y(), line.x())
        arrow_size = 10.0
        p1 = self.line().p2()
        p2 = p1 - QPointF(math.cos(angle + math.pi / 6) * arrow_size, -math.sin(angle + math.pi / 6) * arrow_size)
        p3 = p1 - QPointF(math.cos(angle - math.pi / 6) * arrow_size, -math.sin(angle - math.pi / 6) * arrow_size)
        self.arrow_head = QPolygonF([p1, p2, p3])
        self.update()

    def paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: Optional[QWidget] = None) -> None:
        """
        Paints the connection line and its arrowhead.

        Args:
            painter: The QPainter to use for drawing.
            option: Provides style options for the item.
            widget: The widget that is being painted on, if any.
        """
        painter.setPen(self.pen)
        painter.drawLine(self.line())
        painter.setBrush(Colors.BORDER_DEFAULT)
        painter.drawPolygon(self.arrow_head)


class ProjectVisualizerScene(QGraphicsScene):
    """
    A custom QGraphicsScene to manage the layout and interaction of project nodes.
    """
    def __init__(self, parent=None):
        """
        Initializes the scene and the layout animation timer.
        """
        super().__init__(parent)
        self.layout_timer = QTimer(self)
        self.layout_timer.setInterval(20)  # ~50 FPS
        self.layout_timer.timeout.connect(self._update_layout)
        self._layout_iterations = 0

    def layout_nodes(self) -> None:
        """
        Starts the animated force-directed layout algorithm.
        """
        self._layout_iterations = 0
        if not self.layout_timer.isActive():
            self.layout_timer.start()

    def _update_layout(self) -> None:
        """
        Performs one iteration of the force-directed layout algorithm.
        """
        nodes: List[ProjectNode] = [item for item in self.items() if isinstance(item, ProjectNode)]
        if not nodes or self._layout_iterations > 200:
            self.layout_timer.stop()
            return

        k_repel = 10000  # Repulsion strength
        k_attract = 0.05  # Attraction strength (spring constant)
        damping = 0.95

        forces: Dict[ProjectNode, QPointF] = {node: QPointF(0, 0) for node in nodes}

        # Calculate repulsion forces
        for i in range(len(nodes)):
            for j in range(i + 1, len(nodes)):
                node1, node2 = nodes[i], nodes[j]
                delta = node1.scenePos() - node2.scenePos()
                distance = math.hypot(delta.x(), delta.y())
                if distance < 1:
                    distance = 1
                force = (k_repel / (distance * distance))
                forces[node1] += delta / distance * force
                forces[node2] -= delta / distance * force

        # Calculate attraction forces
        for item in self.items():
            if isinstance(item, ConnectionItem):
                node1, node2 = item.start_node, item.end_node
                delta = node1.scenePos() - node2.scenePos()
                force = k_attract * delta
                forces[node1] -= force
                forces[node2] += force

        # Apply forces
        for node in nodes:
            pos = node.scenePos() + forces[node] * damping
            node.setPos(pos)

        self._layout_iterations += 1


class ProjectVisualizerWindow(QMainWindow):
    """
    The main window for visualizing the project structure as a node graph.
    """
    def __init__(self, event_bus: EventBus, project_manager: ProjectManager):
        """
        Initializes the window, scene, view, and connects to events.

        Args:
            event_bus: The application's central event bus.
            project_manager: The manager for the active project.
        """
        super().__init__()
        self.event_bus = event_bus
        self.project_manager = project_manager
        self.nodes: Dict[str, ProjectNode] = {}

        self.setWindowTitle("Project Visualizer")
        self.setGeometry(150, 150, 1000, 700)

        self._init_ui()

    def _init_ui(self) -> None:
        """
        Sets up the QGraphicsView and QGraphicsScene.
        """
        self.scene = ProjectVisualizerScene(self)
        self.scene.setSceneRect(-2000, -2000, 4000, 4000)
        self.scene.setBackgroundBrush(QColor(Colors.PRIMARY_BG))

        self.view = QGraphicsView(self.scene)
        self.view.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.view.setDragMode(QGraphicsView.DragMode.ScrollHandDrag)
        self.view.setTransformationAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)
        self.view.setResizeAnchor(QGraphicsView.ViewportAnchor.AnchorViewCenter)

        self.setCentralWidget(self.view)

    def clear_graph(self) -> None:
        """
        Clears all nodes and connections from the scene.
        """
        self.scene.clear()
        self.nodes.clear()

    def _handle_project_plan_generated(self, plan: Dict[str, Any]) -> None:
        """
        Builds the node graph from a project plan provided by the Architect.
        This method is connected to an event by the EventCoordinator.

        Args:
            plan: The project plan dictionary.
        """
        logger.info("Visualizer received project plan. Building graph.")
        self.clear_graph()

        # Create a central root node
        root_node = ProjectNode("Project Plan", path=".", node_type="root")
        self.scene.addItem(root_node)
        self.nodes["."] = root_node

        tasks = plan.get("tasks", [])
        if not tasks:
            return

        # Create nodes for all files and their parent directories
        for task in tasks:
            filepath = task.get("filename")
            if not filepath:
                continue

            parts = filepath.split('/')
            current_path = ""
            parent_node = root_node

            for i, part in enumerate(parts):
                if current_path:
                    current_path += "/"
                current_path += part

                is_file = (i == len(parts) - 1)

                if current_path not in self.nodes:
                    node_type = "file" if is_file else "folder"
                    new_node = ProjectNode(part, path=current_path, node_type=node_type)
                    self.scene.addItem(new_node)
                    self.nodes[current_path] = new_node

                    # Connect to parent
                    connection = ConnectionItem(parent_node, new_node)
                    self.scene.addItem(connection)

                parent_node = self.nodes[current_path]

        self.scene.layout_nodes()

    def _handle_file_generation_starting(self, filename: str) -> None:
        """
        Highlights a node when its corresponding file generation begins.
        This method is connected to an event by the EventCoordinator.

        Args:
            filename: The relative path of the file being generated.
        """
        logger.info(f"Visualizer highlighting node for: {filename}")
        self.scene.clearSelection()
        if filename in self.nodes:
            node = self.nodes[filename]
            node.setSelected(True)
            self.view.centerOn(node)